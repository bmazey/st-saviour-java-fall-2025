import java.util.Random;

class Hello {
    public static void main(String[] args) {
        
       //index length stuff
          // String s= "sept";
         // String e = "ember";
         // System.out.println(s + e);
          //String s = "september";
        //char c = s.charAt(s.length()-1);
        //System.out.println(c);      
        //String e = s.substring(4);
        //System.out.println(e);
         //String p = s.substring (4,8)
       //System.out. println (p);
/* int x= 0;
double e = 2.0; 
//casting operator
int g = (int)e;
System.out.println(g);
double h = (double)g;
System.out.println(h);

boolean b = false;
boolean a= true;
if(a && b){
System.out.println("true");
}
else{System.out.println();}

int w= 11;
int j=2;
System.out.println(w/j);
//you will get 5 because both w and j are int. change one of the terms to a double. java tries to preserve the types
//result is in the highest bit type in the operation

String s = "September";
String c = "Sept";
c+= "ember";
//concatenation: use +=
if (s==c){System.out.println("the same");}
      else {System.out.println("not the same");}
      //you will get the else statement, because strings cannot be changed.
      //theres 4 strings. September, sept, ember, and the new string created to make september from the previous 2
      //since the 4th string created to make september is not the same as the original c string
      //the original c string is still present, and since sept doesnt equal september, the else statement will be printed
    Random random = new Random();
        String p= "September";
        int r = random.nextInt(3);
        System.out.println("random number is"+r);  */
    
    
    }

}